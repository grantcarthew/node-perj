const Perj = require('../src/perj')
const Tool = require('./tool')
const tool = new Tool()
const data = require('../data')
const write = tool.write.bind(tool)
const passThrough = true

let log = new Perj({ write, passThrough })

beforeEach(() => {
  tool.reset()
})

describe('log argument tests', () => {
  for (const level of Object.keys(log.levels)) {
    log = new Perj({ level: level, write, passThrough })

    test(level + ': empty', () => {
      log[level]()
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': one undefined', () => {
      log[level](undefined)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': two undefined', () => {
      log[level](undefined, undefined)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data[0]).toBe(null)
      expect(tool.jsonOut.data[1]).toBe(null)
      expect(tool.objOut.data[0]).toBe(null)
      expect(tool.objOut.data[1]).toBe(null)
    })
    test(level + ': one null primitive', () => {
      log[level](null)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': two null primitives', () => {
      log[level](null, null)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data[0]).toBe(null)
      expect(tool.objOut.data[0]).toBe(null)
      expect(tool.jsonOut.data[1]).toBe(null)
      expect(tool.objOut.data[1]).toBe(null)
    })
    test(level + ': one number primitive', () => {
      log[level](42)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(42)
      expect(tool.objOut.data).toBe(42)
    })
    test(level + ': two number primitives', () => {
      log[level](42, 43)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data[0]).toBe(42)
      expect(tool.objOut.data[0]).toBe(42)
      expect(tool.jsonOut.data[1]).toBe(43)
      expect(tool.objOut.data[1]).toBe(43)
    })
    test(level + ': one boolean primitive', () => {
      log[level](true)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(true)
      expect(tool.objOut.data).toBe(true)
    })
    test(level + ': two boolean primitives', () => {
      log[level](true, false)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data[0]).toBe(true)
      expect(tool.objOut.data[0]).toBe(true)
      expect(tool.jsonOut.data[1]).toBe(false)
      expect(tool.objOut.data[1]).toBe(false)
    })
    test(level + ': one message', () => {
      log[level](data.msg[0])
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe(data.msg[0])
      expect(tool.objOut.msg).toBe(data.msg[0])
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': two messages', () => {
      log[level](data.msg[0], data.msg[1])
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.getType(tool.jsonOut.msg)).toBe('String')
      expect(tool.getType(tool.objOut.msg)).toBe('String')
      expect(tool.jsonOut.msg).toBe(data.msg[0])
      expect(tool.objOut.msg).toBe(data.msg[0])
      expect(tool.getType(tool.jsonOut.data)).toBe('String')
      expect(tool.getType(tool.objOut.data)).toBe('String')
      expect(tool.jsonOut.data).toBe(data.msg[1])
      expect(tool.objOut.data).toBe(data.msg[1])
    })
    test(level + ': one object', () => {
      log[level](data.tardis)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.jsonOut.data)
      expect(tool.objOut.data).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.objOut.data)
    })
    test(level + ': two objects', () => {
      log[level](data.tardis, data.serenity)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.objOut.msg).toBe('')
      expect(tool.jsonOut.data[0]).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.jsonOut.data[0])
      expect(tool.objOut.data[0]).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.objOut.data[0])
      expect(tool.jsonOut.data[1]).toMatchObject(data.serenity)
      expect(data.serenity).toMatchObject(tool.jsonOut.data[1])
      expect(tool.objOut.data[1]).toMatchObject(data.serenity)
      expect(data.serenity).toMatchObject(tool.objOut.data[1])
    })
    test(level + ': two messages one data', () => {
      log[level](data.msg[0], data.msg[1], data.tardis)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.getType(tool.jsonOut.msg)).toBe('String')
      expect(tool.getType(tool.objOut.msg)).toBe('String')
      expect(tool.jsonOut.msg).toBe(data.msg[0])
      expect(tool.objOut.msg).toBe(data.msg[0])
      expect(tool.getType(tool.jsonOut.data)).toBe('Array')
      expect(tool.getType(tool.objOut.data)).toBe('Array')
      expect(tool.jsonOut.data[0]).toBe(data.msg[1])
      expect(tool.objOut.data[0]).toBe(data.msg[1])
      expect(tool.jsonOut.data[1]).toMatchObject(data.tardis)
      expect(tool.objOut.data[1]).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.jsonOut.data[1])
      expect(data.tardis).toMatchObject(tool.objOut.data[1])
    })
    test(level + ': two messages two data', () => {
      log[level](data.msg[0], data.msg[1], data.tardis, data.serenity)
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.getType(tool.jsonOut.msg)).toBe('String')
      expect(tool.getType(tool.objOut.msg)).toBe('String')
      expect(tool.jsonOut.msg).toBe(data.msg[0])
      expect(tool.objOut.msg).toBe(data.msg[0])
      expect(tool.getType(tool.jsonOut.data)).toBe('Array')
      expect(tool.getType(tool.objOut.data)).toBe('Array')
      expect(tool.jsonOut.data.length).toBe(3)
      expect(tool.objOut.data.length).toBe(3)
      expect(tool.jsonOut.data[0]).toBe(data.msg[1])
      expect(tool.objOut.data[0]).toBe(data.msg[1])
      expect(tool.jsonOut.data[1]).toMatchObject(data.tardis)
      expect(tool.objOut.data[1]).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.jsonOut.data[1])
      expect(data.tardis).toMatchObject(tool.objOut.data[1])
      expect(tool.jsonOut.data[2]).toMatchObject(data.serenity)
      expect(tool.objOut.data[2]).toMatchObject(data.serenity)
      expect(data.serenity).toMatchObject(tool.jsonOut.data[2])
      expect(data.serenity).toMatchObject(tool.objOut.data[2])
    })
    test(level + ': two messages two data mixed order', () => {
      log[level](data.tardis, data.msg[1], data.serenity, data.msg[0])
      expect(Object.keys(tool.jsonOut).length).toBe(5)
      expect(Object.keys(tool.objOut).length).toBe(5)
      expect(tool.getType(tool.jsonOut.time)).toBe('Number')
      expect(tool.getType(tool.objOut.time)).toBe('Number')
      expect(tool.jsonOut.level).toBe(level)
      expect(tool.objOut.level).toBe(level)
      expect(tool.getType(tool.jsonOut.msg)).toBe('String')
      expect(tool.getType(tool.objOut.msg)).toBe('String')
      expect(tool.jsonOut.msg).toBe(data.msg[1])
      expect(tool.objOut.msg).toBe(data.msg[1])
      expect(tool.getType(tool.jsonOut.data)).toBe('Array')
      expect(tool.getType(tool.objOut.data)).toBe('Array')
      expect(tool.jsonOut.data.length).toBe(3)
      expect(tool.objOut.data.length).toBe(3)
      expect(tool.jsonOut.data[0]).toMatchObject(data.tardis)
      expect(tool.objOut.data[0]).toMatchObject(data.tardis)
      expect(data.tardis).toMatchObject(tool.jsonOut.data[0])
      expect(data.tardis).toMatchObject(tool.objOut.data[0])
      expect(tool.jsonOut.data[1]).toMatchObject(data.serenity)
      expect(tool.objOut.data[1]).toMatchObject(data.serenity)
      expect(data.serenity).toMatchObject(tool.jsonOut.data[1])
      expect(data.serenity).toMatchObject(tool.objOut.data[1])
      expect(tool.jsonOut.data[2]).toBe(data.msg[0])
      expect(tool.objOut.data[2]).toBe(data.msg[0])
    })
    test(level + ': single string test', () => {
      let log = new Perj({ passThrough, write })
      log.info('string')
      expect(tool.jsonOut.msg).toBe('string')
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.msg).toBe('string')
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': single number test', () => {
      let log = new Perj({ passThrough, write })
      log.info(123)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(123)
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toBe(123)
    })
    test(level + ': single empty array test', () => {
      let log = new Perj({ passThrough, write })
      log.info([])
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual([])
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual([])
    })
    test(level + ': single array test', () => {
      let log = new Perj({ passThrough, write })
      log.info([1, 2, 3])
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual([1, 2, 3])
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual([1, 2, 3])
    })
    test(level + ': single object test', () => {
      let log = new Perj({ passThrough, write })
      log.info({ key: 'value' })
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual({ key: 'value' })
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual({ key: 'value' })
    })
    test(level + ': single boolean test', () => {
      let log = new Perj({ passThrough, write })
      log.info(true)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual(true)
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual(true)
    })
    test(level + ': single date test', () => {
      let log = new Perj({ passThrough, write })
      log.info(new Date())
      expect(tool.jsonOut.msg).toBe('')
      expect(typeof Date.parse(tool.jsonOut.data)).toBe('number')
      expect(tool.objOut.msg).toBe('')
      expect(typeof Date.parse(tool.objOut.data)).toBe('number')
    })
    test(level + ': single error test', () => {
      let log = new Perj({ passThrough, write })
      log.info(new Error())
      expect(tool.jsonOut.msg).toBe('')
      expect(typeof tool.jsonOut.data).toBe('object')
      expect(tool.objOut.msg).toBe('')
      expect(typeof tool.objOut.data).toBe('object')
    })
    test(level + ': single null test', () => {
      let log = new Perj({ passThrough, write })
      log.info(null)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': single undefined test', () => {
      let log = new Perj({ passThrough, write })
      log.info(undefined)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toBe(null)
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toBe(null)
    })
    test(level + ': single empty object test', () => {
      let log = new Perj({ passThrough, write })
      log.info({})
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual({})
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual({})
    })
    test(level + ': single function test', () => {
      let log = new Perj({ passThrough, write })
      log.info(function () {})
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual(null)
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual(null)
    })
    test(level + ': single circular object test', () => {
      let log = new Perj({ passThrough, write })
      let circ = { key: 1 }
      circ.inner = circ
      log.info(circ)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data.key).toBe(1)
      expect(tool.jsonOut.data.inner).toBe('[Circular]')
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data.key).toBe(1)
      expect(tool.objOut.data.inner).toBe('[Circular]')
    })
    test(level + ': single circular function test', () => {
      let log = new Perj({ passThrough, write })
      let circFun = function () { }
      circFun.key = 2
      circFun.repeat = circFun
      log.info(circFun)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data).toEqual(null)
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data).toEqual(null)
    })
    test(level + ': object with buffer test', () => {
      let log = new Perj({ passThrough, write })
      let obj = { foo: Buffer.from('bar') }
      log.info(obj)
      expect(tool.jsonOut.msg).toBe('')
      expect(tool.jsonOut.data.foo.type).toEqual('Buffer')
      expect(tool.jsonOut.data.foo.utf8).toEqual('bar')
      expect(tool.objOut.msg).toBe('')
      expect(tool.objOut.data.foo.type).toEqual('Buffer')
      expect(tool.objOut.data.foo.utf8).toEqual('bar')
    })
  }
})
